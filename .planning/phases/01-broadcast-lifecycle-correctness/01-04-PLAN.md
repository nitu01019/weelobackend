---
phase: 01-broadcast-lifecycle-correctness
plan: 04
type: execute
wave: 3
depends_on:
  - 01-03
files_modified:
  - src/modules/booking/booking.service.ts
  - src/modules/order/order.service.ts
autonomous: true
requirements:
  - IDEM-01
  - IDEM-02
  - IDEM-03

must_haves:
  truths:
    - "Double-tapping the search button creates exactly one broadcast — the second tap returns the existing broadcast"
    - "A network retry of the same search request reuses the existing broadcast, not creates a duplicate"
    - "The idempotency key is generated server-side from request parameters — the client does not need to supply one"
  artifacts:
    - path: "src/modules/booking/booking.service.ts"
      provides: "Server-generated idempotency key with Redis TTL dedup in createBooking"
      contains: "idem:broadcast:create"
    - path: "src/modules/order/order.service.ts"
      provides: "Server-generated idempotency key with Redis TTL dedup in createOrder"
      contains: "idem:broadcast:create"
  key_links:
    - from: "src/modules/booking/booking.service.ts"
      to: "redisService.get"
      via: "Check Redis for existing idempotency key before creating broadcast"
      pattern: "idem:broadcast:create"
    - from: "src/modules/booking/booking.service.ts"
      to: "redisService.set"
      via: "Store idempotency key -> bookingId mapping after successful creation"
      pattern: "idem:broadcast:create.*set"
    - from: "src/modules/order/order.service.ts"
      to: "redisService"
      via: "Same idempotency dedup pattern for Order path"
      pattern: "idem:broadcast:create"
---

<objective>
Implement server-generated idempotency keys for broadcast creation on both Booking and Order paths, using a SHA-256 hash of request parameters stored in Redis with TTL-based dedup.

Purpose: Currently, the client-supplied idempotency key is optional. If the client does not send one (or sends different keys for the same intent), duplicate broadcasts are created. Network retries and double-taps both produce duplicates. Server-generated keys from request parameters eliminate this gap entirely — no client cooperation needed.

Output: Both `createBooking()` and `createOrder()` generate a deterministic idempotency key from request parameters, check Redis for existing broadcast, and return the cached broadcast on duplicates.
</objective>

<execution_context>
@/Users/nitishbhardwaj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nitishbhardwaj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-RESEARCH.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-03-SUMMARY.md
@src/modules/booking/booking.service.ts
@src/modules/order/order.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement server-generated idempotency in createBooking</name>
  <files>src/modules/booking/booking.service.ts</files>
  <action>
Read `src/modules/booking/booking.service.ts` and find `createBooking()`. The existing code may already have a client-supplied idempotency key check. The new implementation should REPLACE or PRECEDE it with a server-generated key.

**Add the idempotency check AFTER the one-per-customer guard (from Plan 03) but BEFORE any DB writes:**

```typescript
import crypto from 'crypto';

// Server-generated idempotency key from request fingerprint
// Round coordinates to 3 decimal places to prevent floating-point differences
const roundCoord = (n: number) => Math.round(n * 1000) / 1000;
const idempotencyFingerprint = [
  customerId,
  vehicleType,
  vehicleSubtype || '',
  roundCoord(pickup.lat),
  roundCoord(pickup.lng),
  roundCoord(drop.lat),
  roundCoord(drop.lng)
].join(':');
const idempotencyHash = crypto.createHash('sha256').update(idempotencyFingerprint).digest('hex').substring(0, 16);
const dedupeKey = `idem:broadcast:create:${customerId}:${idempotencyHash}`;

// Check for existing broadcast with same parameters
const existingId = await redisService.get(dedupeKey);
if (existingId) {
  // Return the existing booking (idempotent replay)
  const existingBooking = await db.getBookingById(existingId);
  if (existingBooking && !['cancelled', 'expired'].includes(existingBooking.status)) {
    logger.info('Idempotent replay: returning existing booking', { bookingId: existingId, idempotencyHash });
    return existingBooking;
  }
  // If existing booking is cancelled/expired or not found, allow new creation
  // (stale dedup key — will be overwritten below)
}
```

**AFTER the booking is successfully created (DB write committed), store the dedup key:**

```typescript
const timeoutSeconds = parseInt(process.env.BROADCAST_TIMEOUT_SECONDS || '120', 10);
await redisService.set(dedupeKey, newBookingId, timeoutSeconds + 30); // TTL = timeout + 30s buffer
logger.info('Idempotency key stored', { bookingId: newBookingId, idempotencyHash });
```

**If the existing client-supplied idempotency logic exists**, keep it as a secondary check but make the server-generated key the PRIMARY dedup mechanism. The server key fires first; if it does not find a match, the old client key logic can run. Or simply remove the client-supplied key reliance and rely entirely on the server-generated key. Read the existing code to decide — the research recommends replacing client-supplied with server-generated.

**Cleanup:** The dedup key should also be deleted on terminal transitions. Add `idem:broadcast:create:${customerId}:*` cleanup alongside the `customer:active-broadcast` cleanup that Plan 03 added. Since we cannot use Redis KEYS/SCAN on ElastiCache, store a "latest idempotency key" pointer:

```typescript
// After setting the dedup key:
await redisService.set(`idem:broadcast:latest:${customerId}`, dedupeKey, timeoutSeconds + 30);
```

In the terminal cleanup helper (from Plan 03), add:
```typescript
const latestIdemKey = await redisService.get(`idem:broadcast:latest:${customerId}`);
if (latestIdemKey) {
  await redisService.del(latestIdemKey).catch(() => {});
  await redisService.del(`idem:broadcast:latest:${customerId}`).catch(() => {});
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. Grep for `idem:broadcast:create` in `booking.service.ts` to confirm the dedup key is checked and set. Grep for `createHash.*sha256` to confirm server-side key generation. Verify that the idempotency check returns the existing booking (not throws an error).
  </verify>
  <done>
`createBooking()` generates a server-side idempotency key from `customerId + vehicleType + vehicleSubtype + pickup + drop` coordinates. Double-taps and network retries return the existing booking. The dedup key has a TTL matching broadcast timeout + 30s. Terminal transitions clean up the dedup key via a latest-pointer pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement server-generated idempotency in createOrder</name>
  <files>src/modules/order/order.service.ts</files>
  <action>
Read `src/modules/order/order.service.ts` and find `createOrder()`. Apply the SAME server-generated idempotency pattern as Task 1.

The Order path may have different request parameters (multiple truck types instead of a single vehicleType). Adapt the fingerprint:

```typescript
// For orders with multiple truck types, include them in the fingerprint
const truckTypesSorted = request.trucks
  .map(t => `${t.vehicleType}:${t.vehicleSubtype || ''}:${t.quantity}`)
  .sort()
  .join('|');

const idempotencyFingerprint = [
  customerId,
  truckTypesSorted,
  roundCoord(pickup.lat),
  roundCoord(pickup.lng),
  roundCoord(drop.lat),
  roundCoord(drop.lng)
].join(':');
```

The rest of the pattern is identical:
1. Generate SHA-256 hash, check Redis dedup key
2. If exists and order is still active, return existing order (idempotent replay)
3. If not, proceed with creation
4. After creation, store dedup key with TTL
5. Store latest-pointer for cleanup
6. Terminal cleanup deletes dedup key

The dedup key namespace is the same: `idem:broadcast:create:${customerId}:${hash}`. This means a booking and order with different parameters won't collide, but the same request repeated will be caught.

Read the existing `createOrder` carefully for its return type — it may return a `CreateOrderResponse` object rather than the raw order record. The idempotent replay should return the same response shape.

**If the existing createOrder has client-supplied idempotency (check `order.routes.ts` for `X-Idempotency-Key` header)**, replace it with the server-generated key as the primary mechanism.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. Grep for `idem:broadcast:create` in `order/order.service.ts` to confirm the dedup key is checked and set. Grep for `createHash.*sha256` to confirm server-side key generation. Verify that the idempotency check returns the existing order (not throws an error).
  </verify>
  <done>
`createOrder()` generates a server-side idempotency key from `customerId + sorted truck types + pickup + drop` coordinates. Double-taps and network retries return the existing order. The dedup key has a TTL matching broadcast timeout + 30s. Terminal transitions clean up the dedup key. Both Booking and Order paths now have consistent server-generated idempotency.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Both createBooking and createOrder have server-generated idempotency key logic
3. Keys are deterministic from request parameters (same params = same key)
4. Redis dedup key is checked before creation and set after creation
5. Duplicate requests return existing broadcast (not error)
6. Terminal cleanup removes idempotency keys
7. No client-supplied key is required (server generates it)
</verification>

<success_criteria>
- Double-tap search: one broadcast created, second request returns the existing one
- Network retry: reuses existing broadcast
- Idempotency key is server-generated (client does not need to send it)
- Dedup key has TTL and is cleaned on terminal state
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-broadcast-lifecycle-correctness/01-04-SUMMARY.md`
</output>
