---
phase: 01-broadcast-lifecycle-correctness
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/modules/booking/booking.service.ts
  - src/modules/order/order.service.ts
  - src/modules/order/order.routes.ts
autonomous: true
requirements:
  - CUST-01
  - CUST-02
  - CUST-03
  - CUST-04

must_haves:
  truths:
    - "A customer with an active broadcast cannot create a second broadcast — they see 'Request already in progress. Cancel it first.'"
    - "Two different customers can each have their own active broadcast concurrently without blocking each other"
    - "After a broadcast reaches terminal state (cancelled, expired, fully_filled), the customer can immediately start a new search"
    - "The one-per-customer check works across both Booking and Order paths — customer cannot have active booking AND active order simultaneously"
  artifacts:
    - path: "src/modules/booking/booking.service.ts"
      provides: "One-per-customer guard in createBooking with Redis lock + DB check, terminal cleanup of customer:active-broadcast key"
      contains: "customer:active-broadcast"
    - path: "src/modules/order/order.service.ts"
      provides: "One-per-customer guard in createOrder with Redis lock + DB check, terminal cleanup of customer:active-broadcast key"
      contains: "customer:active-broadcast"
  key_links:
    - from: "src/modules/booking/booking.service.ts"
      to: "redisService.acquireLock"
      via: "Distributed lock on customer-broadcast-create:{customerId} during create critical section"
      pattern: "acquireLock.*customer-broadcast-create"
    - from: "src/modules/booking/booking.service.ts"
      to: "redisService.set"
      via: "Sets customer:active-broadcast:{customerId} after successful broadcast creation"
      pattern: "customer:active-broadcast"
    - from: "src/modules/order/order.service.ts"
      to: "redisService.acquireLock"
      via: "Same distributed lock pattern for Order path"
      pattern: "acquireLock.*customer-broadcast-create"
    - from: "src/modules/booking/booking.service.ts"
      to: "redisService.del"
      via: "Deletes customer:active-broadcast key on terminal transitions (expire, cancel, fully_filled)"
      pattern: "del.*customer:active-broadcast"
---

<objective>
Enforce one-active-broadcast-per-customer at the server level with a Redis distributed lock + DB authoritative check on both Booking and Order creation paths, and clear the customer active key on all terminal state transitions.

Purpose: Currently nothing prevents a customer from creating multiple simultaneous broadcasts. Two rapid search taps, or concurrent Booking + Order requests, can create parallel broadcasts — confusing transporters with duplicates and producing inconsistent state. This plan adds the server-side guard that makes it impossible.

Output: Both `createBooking()` and `createOrder()` enforce one-per-customer. All terminal paths (cancel, expire, fully_filled) clear the customer active-broadcast key so new searches are unblocked.
</objective>

<execution_context>
@/Users/nitishbhardwaj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nitishbhardwaj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-RESEARCH.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-01-SUMMARY.md
@src/modules/booking/booking.service.ts
@src/modules/order/order.service.ts
@src/modules/order/order.routes.ts
@src/shared/services/redis.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add one-per-customer guard to createBooking and createOrder</name>
  <files>src/modules/booking/booking.service.ts, src/modules/order/order.service.ts, src/modules/order/order.routes.ts</files>
  <action>
**In `src/modules/booking/booking.service.ts`, at the TOP of `createBooking()` (before any DB writes):**

Add the three-step guard from the research:

```typescript
// Step 1: Redis fast path check
const activeKey = `customer:active-broadcast:${customerId}`;
const existingBroadcastId = await redisService.get(activeKey);
if (existingBroadcastId) {
  throw new AppError(409, 'ORDER_ACTIVE_EXISTS', 'Request already in progress. Cancel it first.');
}

// Step 2: Distributed lock to prevent TOCTOU race on concurrent requests
const lockKey = `lock:customer-broadcast-create:${customerId}`;
const lock = await redisService.acquireLock(lockKey, customerId, 10); // 10 second TTL
if (!lock.acquired) {
  throw new AppError(409, 'ORDER_ACTIVE_EXISTS', 'Request already in progress. Cancel it first.');
}

try {
  // Step 3: DB authoritative check (covers Redis failure edge case)
  // Check BOTH bookings and orders — customer cannot have active booking AND active order
  const existingBooking = await prismaClient.booking.findFirst({
    where: { customerId, status: { in: ['created', 'broadcasting', 'active', 'partially_filled'] } }
  });
  const existingOrder = await prismaClient.order.findFirst({
    where: { customerId, status: { in: ['created', 'broadcasting', 'active', 'partially_filled'] } }
  });
  if (existingBooking || existingOrder) {
    throw new AppError(409, 'ORDER_ACTIVE_EXISTS', 'Request already in progress. Cancel it first.');
  }

  // ... existing createBooking logic ...

  // After successful creation, set the Redis active key
  const timeoutSeconds = parseInt(process.env.BROADCAST_TIMEOUT_SECONDS || '120', 10);
  await redisService.set(activeKey, bookingId, timeoutSeconds + 60); // TTL = timeout + 60s buffer

} finally {
  await redisService.releaseLock(lockKey, customerId);
}
```

NOTE: The error code `ORDER_ACTIVE_EXISTS` already exists in the codebase (used in `order.routes.ts`). Reuse it for consistency. The message must be "Request already in progress. Cancel it first." per requirement CUST-02.

NOTE: The DB check includes the new lifecycle states from Plan 01 (`created`, `broadcasting`). If Plan 01 has not been applied yet, Prisma will error — this is why this plan depends on 01-01.

**In `src/modules/order/order.service.ts`, at the TOP of `createOrder()`:**

Apply the EXACT SAME three-step guard. The `createOrder` method currently has a "PER-CUSTOMER ORDER DEBOUNCE (3 second cooldown)" at the top. The one-per-customer guard should go AFTER that debounce check (or replace it, since the one-per-customer guard is strictly stronger). Check what the existing debounce does — if it just prevents rapid-fire, keep it and add the guard after it. If it already does an active-order check, replace it with the proper guard.

The Redis `activeKey` is the SAME key (`customer:active-broadcast:${customerId}`) used by both Booking and Order paths. This means a customer cannot have BOTH an active booking and an active order. This is intentional per CUST-01.

**In `src/modules/order/order.routes.ts`:**

The routes file has its own one-active-order check (around line 151). This check is at the route level. Keep it as a fast-fail but update it to use the Redis key check (`customer:active-broadcast:{customerId}`) for consistency. Or leave it as-is if it already calls the service which now has the guard. Read the routes file to decide — the service-level guard is authoritative; the route-level check is optional fast-fail.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compilation. Grep for `customer:active-broadcast` in both service files to confirm the Redis key is used. Grep for `acquireLock.*customer-broadcast-create` to confirm the distributed lock. Grep for `ORDER_ACTIVE_EXISTS` to confirm the error code is used in both paths.
  </verify>
  <done>
Both `createBooking()` and `createOrder()` enforce one-active-broadcast-per-customer via Redis fast-path + distributed lock + DB authoritative check. The guard checks BOTH bookings and orders tables. The error message is "Request already in progress. Cancel it first." Different customers are not affected (key is per-customer).
  </done>
</task>

<task type="auto">
  <name>Task 2: Clear customer active-broadcast key on all terminal state transitions</name>
  <files>src/modules/booking/booking.service.ts, src/modules/order/order.service.ts</files>
  <action>
For CUST-04 (customer can start new search after terminal state), the `customer:active-broadcast:{customerId}` Redis key MUST be deleted on every terminal state transition. This is critical — if the key is not cleaned up, the customer is permanently blocked.

Create a small helper function (can be inline or a private method) in each service:

```typescript
private async clearCustomerActiveBroadcast(customerId: string): Promise<void> {
  const activeKey = `customer:active-broadcast:${customerId}`;
  await redisService.del(activeKey).catch((err) => {
    logger.warn('Failed to clear customer active broadcast key', { customerId, error: err.message });
  });
}
```

Call this helper in EVERY terminal state transition path:

**In `booking.service.ts`:**
1. `cancelBooking()` — after the booking is cancelled
2. `handleBookingTimeout()` or the expiry handler — after the booking is expired
3. The fully_filled transition (wherever `status: 'fully_filled'` is set) — after all trucks are filled
4. Any other path that sets status to `completed` or another terminal state

**In `order/order.service.ts`:**
1. `cancelOrder()` — after the order is cancelled
2. The order expiry/timeout handler — after the order is expired
3. The fully_filled transition in the accept flow — after all trucks are filled
4. Any other path that sets status to `completed` or another terminal state

To find all terminal transition paths, grep for:
- `status: 'cancelled'` or `status: 'expired'` or `status: 'fully_filled'` or `status: 'completed'`
- Each occurrence that updates a booking/order status to one of these values must include the `clearCustomerActiveBroadcast(customerId)` call.

IMPORTANT: Use `.catch()` on the Redis delete so that a Redis failure does not prevent the terminal transition from completing. The Redis key has a TTL anyway (timeout + 60s), so it will auto-expire even if deletion fails.

IMPORTANT: The helper must be called AFTER the DB update succeeds (not before), to avoid clearing the key while the broadcast is still technically active.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. Grep for `clearCustomerActiveBroadcast` (or `customer:active-broadcast` + `del`) in both service files to confirm it is called in all terminal paths. Count the number of terminal transitions and verify each has the cleanup call. Specifically verify: cancelBooking, handleBookingTimeout, fully_filled path in booking.service.ts; cancelOrder, order expiry handler, fully_filled path in order/order.service.ts.
  </verify>
  <done>
Every terminal state transition (cancel, expire, fully_filled, completed) in both booking.service.ts and order/order.service.ts clears the `customer:active-broadcast:{customerId}` Redis key. Customer is unblocked immediately after terminal state. Cleanup is fire-and-forget with catch to prevent Redis errors from blocking the main flow.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Both createBooking and createOrder have Redis + lock + DB guard at top
3. Both use the same `customer:active-broadcast:{customerId}` key namespace
4. All terminal paths clean up the customer active key
5. Different customers' keys are independent (no cross-customer blocking)
6. Error code `ORDER_ACTIVE_EXISTS` with message "Request already in progress. Cancel it first." returned on duplicate
</verification>

<success_criteria>
- Customer with active broadcast gets 409 with "Request already in progress. Cancel it first."
- Guard works across Booking and Order paths (customer cannot have both)
- Different customers are not affected
- After cancel/expire/fully_filled, customer can immediately create new search
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-broadcast-lifecycle-correctness/01-03-SUMMARY.md`
</output>
