---
phase: 01-broadcast-lifecycle-correctness
plan: 05
type: execute
wave: 4
depends_on:
  - 01-01
  - 01-02
  - 01-03
files_modified:
  - src/modules/booking/booking.service.ts
  - src/modules/order/order.service.ts
autonomous: true
requirements:
  - CNCL-01
  - CNCL-02
  - CNCL-05
  - CNCL-06
  - CNCL-07

must_haves:
  truths:
    - "Customer can cancel their active broadcast at any point while it is active or partially_filled"
    - "Cancel is immediate — a single atomic UPDATE WHERE status IN (active, partially_filled) transitions the status"
    - "Cancel clears ALL Redis state: customer:active-broadcast key, idempotency key, broadcast timers, notified transporter set"
    - "Cancel is idempotent — calling cancel on an already-cancelled broadcast returns 200 success, not an error"
    - "Cancel-vs-accept race: if cancel and accept happen simultaneously, cancel wins — the transporter does not get a confirmed assignment on a cancelled broadcast"
  artifacts:
    - path: "src/modules/booking/booking.service.ts"
      provides: "Atomic cancelBooking with updateMany WHERE status IN (active, partially_filled), idempotent on repeat, full Redis cleanup"
      contains: "updateMany"
    - path: "src/modules/order/order.service.ts"
      provides: "Atomic cancelOrder with updateMany WHERE status IN (active, partially_filled), idempotent on repeat, full Redis cleanup"
      contains: "updateMany"
  key_links:
    - from: "src/modules/booking/booking.service.ts"
      to: "prismaClient.booking.updateMany"
      via: "Atomic cancel: UPDATE WHERE id AND customerId AND status IN (active, partially_filled)"
      pattern: "updateMany.*status.*in.*active.*partially_filled"
    - from: "src/modules/booking/booking.service.ts"
      to: "redisService"
      via: "Full Redis cleanup on cancel: timers, notified set, customer active key, idempotency key"
      pattern: "clearBookingTimers|clearCustomerActiveBroadcast|del.*idem"
    - from: "src/modules/order/order.service.ts"
      to: "prismaClient.order.updateMany"
      via: "Atomic cancel for Order path"
      pattern: "updateMany.*status.*in.*active.*partially_filled"
---

# Broadcast Lifecycle Correctness — Plan 01-05

<objective>
Implement race-safe, idempotent cancel for both Booking and Order paths using atomic UPDATE WHERE status IN (active, partially_filled), with full Redis state cleanup and cancel-wins-over-accept semantics.

Purpose: The current cancelBooking() does a read-check-write (reads booking, checks status in app code, then updates). This allows an accept to sneak in between the read and write, producing a confirmed assignment on a cancelled booking. Additionally, cancelling an already-cancelled booking throws an error instead of being idempotent. This plan makes cancel atomic, idempotent, and authoritative over concurrent accepts.

Output: Both `cancelBooking()` and `cancelOrder()` use atomic `updateMany` with status precondition, return success on already-cancelled, clear all Redis state, and win over concurrent accepts.
</objective>

<execution_context>
@/Users/nitishbhardwaj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nitishbhardwaj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-RESEARCH.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-01-SUMMARY.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-02-SUMMARY.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-03-SUMMARY.md
@src/modules/booking/booking.service.ts
@src/modules/order/order.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement atomic idempotent cancelBooking</name>
  <files>src/modules/booking/booking.service.ts</files>
  <action>
Read `src/modules/booking/booking.service.ts` and find the existing `cancelBooking()` method (around line 1045). The current implementation:
1. Reads the booking with `db.getBookingById(bookingId)`
2. Checks status in application code
3. Throws 400 if already cancelled
4. Updates status to cancelled

Replace the method body with the atomic pattern:

```typescript
async cancelBooking(bookingId: string, customerId: string): Promise<BookingRecord> {
  // ATOMIC cancel: only succeeds if status is still cancellable
  // This is the key to winning cancel-vs-accept races
  const updated = await prismaClient.booking.updateMany({
    where: {
      id: bookingId,
      customerId,  // Ownership check baked into the atomic operation
      status: { in: ['created', 'broadcasting', 'active', 'partially_filled'] }
    },
    data: {
      status: 'cancelled',
      stateChangedAt: new Date()
    }
  });

  // Fetch current state for response and post-cancel logic
  const booking = await prismaClient.booking.findUnique({ where: { id: bookingId } });

  if (!booking) {
    throw new AppError(404, 'BOOKING_NOT_FOUND', 'Booking not found');
  }

  if (booking.customerId !== customerId) {
    throw new AppError(403, 'FORBIDDEN', 'Not your booking');
  }

  // IDEMPOTENT: already cancelled is success (not error)
  if (updated.count === 0 && booking.status === 'cancelled') {
    logger.info('Idempotent cancel: booking already cancelled', { bookingId });
    return booking;
  }

  if (updated.count === 0) {
    // Status was not cancellable (completed, expired, fully_filled, in_progress)
    throw new AppError(409, 'BOOKING_CANNOT_CANCEL',
      `Cannot cancel booking in ${booking.status} state`);
  }

  // === CANCEL WON: Full cleanup ===

  // 1. Clear all booking timers (existing method)
  await this.clearBookingTimers(bookingId);

  // 2. Clear customer active broadcast key (from Plan 03)
  await this.clearCustomerActiveBroadcast(customerId);

  // 3. Clear idempotency key (from Plan 04)
  const latestIdemKey = await redisService.get(`idem:broadcast:latest:${customerId}`);
  if (latestIdemKey) {
    await redisService.del(latestIdemKey).catch(() => {});
    await redisService.del(`idem:broadcast:latest:${customerId}`).catch(() => {});
  }

  // 4. Clear notified transporter set
  await redisService.del(`broadcast:notified:${bookingId}`).catch(() => {});

  // 5. CANCEL-VS-ACCEPT RACE RESOLUTION (CNCL-07):
  // Check if any assignments were created in the last few seconds (accept snuck in)
  // If so, mark them as cancelled too
  const recentAssignments = await prismaClient.assignment.findMany({
    where: {
      bookingId,
      status: { in: ['pending', 'driver_accepted'] },
      createdAt: { gte: new Date(Date.now() - 5000) } // Last 5 seconds
    }
  });

  if (recentAssignments.length > 0) {
    await prismaClient.assignment.updateMany({
      where: {
        bookingId,
        status: { in: ['pending', 'driver_accepted'] }
      },
      data: { status: 'cancelled' }
    });
    logger.warn('Cancel-vs-accept race: reverted assignments', {
      bookingId,
      assignmentCount: recentAssignments.length
    });
  }

  // 6. Notify all notified transporters (existing fan-out pattern)
  // Emit BOOKING_CANCELLED to customer and all notified transporters
  emitToUser(customerId, SocketEvent.BOOKING_CANCELLED || 'BOOKING_CANCELLED', {
    bookingId,
    status: 'cancelled',
    stateChangedAt: new Date().toISOString()
  });

  // Fan out to all notified transporters using the stored set
  // (Use existing notification pattern from handleBookingTimeout or similar)
  // Read the existing code to find how expired notifications are sent to transporters
  // and replicate that pattern for cancel

  logger.info('Booking cancelled successfully', { bookingId, customerId });
  return booking;
}
```

CRITICAL NOTES:
- The `updateMany` is the ATOMIC operation that prevents cancel-vs-accept race. If accept commits first (changing status to partially_filled or fully_filled), cancel's updateMany returns count=0, and we check if it's acceptable to cancel in that state.
- If cancel commits first (status -> cancelled), accept's updateMany (from Plan 02) will return count=0 because the TruckRequest's parent booking is now cancelled. The accept gets 409 "Request already taken".
- The assignment revert (step 5) catches the edge case where accept created an assignment in the milliseconds between cancel's read and write.
- The existing `clearBookingTimers()` method already exists — just call it. Do NOT rewrite timer cleanup logic.
- Read the existing method to preserve any notification logic (FCM push to transporters, etc.) that is currently there.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. Grep for `updateMany.*status.*in.*active.*partially_filled` in `booking.service.ts` to confirm the atomic cancel. Grep for `booking.status === 'cancelled'` to confirm idempotent handling (return, not throw). Grep for `clearBookingTimers|clearCustomerActiveBroadcast` to confirm Redis cleanup.
  </verify>
  <done>
`cancelBooking()` uses atomic `updateMany` with status precondition. Already-cancelled returns success (idempotent). Full Redis cleanup: timers, notified set, customer active key, idempotency key. Cancel-vs-accept race handled by reverting any assignments created in the race window. Transporters notified via WebSocket.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement atomic idempotent cancelOrder</name>
  <files>src/modules/order/order.service.ts</files>
  <action>
Read `src/modules/order/order.service.ts` and find the existing `cancelOrder()` method (around line 1216). The current implementation does a read-check-write and returns `{ success: false }` instead of throwing on already-cancelled.

Replace the method body with the atomic pattern, adapted for the Order path:

```typescript
async cancelOrder(
  orderId: string,
  customerId: string,
  reason?: string
): Promise<{ success: boolean; message: string; transportersNotified: number }> {
  // ATOMIC cancel: only succeeds if status is still cancellable
  const updated = await prismaClient.order.updateMany({
    where: {
      id: orderId,
      customerId,
      status: { in: ['created', 'broadcasting', 'active', 'partially_filled'] }
    },
    data: {
      status: 'cancelled',
      stateChangedAt: new Date()
    }
  });

  // Fetch current state
  const order = await prismaClient.order.findUnique({ where: { id: orderId } });

  if (!order) {
    return { success: false, message: 'Order not found', transportersNotified: 0 };
  }

  if (order.customerId !== customerId) {
    return { success: false, message: 'You can only cancel your own orders', transportersNotified: 0 };
  }

  // IDEMPOTENT: already cancelled is success
  if (updated.count === 0 && order.status === 'cancelled') {
    return { success: true, message: 'Order already cancelled', transportersNotified: 0 };
  }

  if (updated.count === 0) {
    return { success: false, message: `Cannot cancel order in ${order.status} state`, transportersNotified: 0 };
  }

  // === CANCEL WON: Full cleanup ===

  // 1. Cancel all associated TruckRequests atomically
  await prismaClient.truckRequest.updateMany({
    where: {
      orderId,
      status: { in: ['searching', 'held'] }
    },
    data: {
      status: 'cancelled'
    }
  });

  // 2. Clear order expiry timer
  await redisService.cancelTimer(this.TIMER_KEYS.ORDER_EXPIRY(orderId)).catch(() => {});

  // 3. Clear customer active broadcast key
  await this.clearCustomerActiveBroadcast(customerId);

  // 4. Clear idempotency key
  const latestIdemKey = await redisService.get(`idem:broadcast:latest:${customerId}`);
  if (latestIdemKey) {
    await redisService.del(latestIdemKey).catch(() => {});
    await redisService.del(`idem:broadcast:latest:${customerId}`).catch(() => {});
  }

  // 5. CANCEL-VS-ACCEPT RACE RESOLUTION (CNCL-07):
  // Revert any assignments created in the race window
  const recentAssignments = await prismaClient.assignment.findMany({
    where: {
      orderId,
      status: { in: ['pending', 'driver_accepted'] },
      createdAt: { gte: new Date(Date.now() - 5000) }
    }
  });

  if (recentAssignments.length > 0) {
    await prismaClient.assignment.updateMany({
      where: {
        orderId,
        status: { in: ['pending', 'driver_accepted'] }
      },
      data: { status: 'cancelled' }
    });
    logger.warn('Cancel-vs-accept race: reverted order assignments', {
      orderId,
      assignmentCount: recentAssignments.length
    });
  }

  // 6. Notify transporters (keep existing fan-out logic)
  // Read the existing cancelOrder code for the transporter notification pattern
  // and replicate it. The existing code already fans out BOOKING_CANCELLED to notified transporters.
  // Count and return the number of transporters notified.

  let transportersNotified = 0;
  // ... existing notification logic to count and notify transporters ...

  // 7. Notify customer
  emitToUser(customerId, 'BOOKING_CANCELLED', {
    orderId,
    status: 'cancelled',
    reason: reason || 'Customer cancelled',
    stateChangedAt: new Date().toISOString()
  });

  logger.info('Order cancelled successfully', { orderId, customerId, transportersNotified });
  return { success: true, message: 'Order cancelled successfully', transportersNotified };
}
```

IMPORTANT: The existing `cancelOrder` has notification logic that fans out to notified transporters. READ the existing method carefully and PRESERVE that notification logic. The code above shows the pattern but the actual transporter notification may use `emitToUser` in a loop, or use a Redis set of notified transporters. Keep what works.

IMPORTANT: The existing method also cancels TruckRequests. The atomic cancel pattern above handles this — cancel all searching/held TruckRequests in one batch updateMany. Assignments that were already confirmed (driver en route) should NOT be cancelled — only pending ones.

IMPORTANT: The return type must match the existing signature: `{ success, message, transportersNotified }`. Do NOT change the return type as the routes depend on it.

Also ensure the method handles the `clearCustomerActiveBroadcast` helper. If this helper was not added to `order.service.ts` in Plan 03, add it now (same implementation as in booking.service.ts).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. Grep for `updateMany.*status.*in.*active.*partially_filled` in `order/order.service.ts` to confirm the atomic cancel. Grep for `order.status === 'cancelled'` to confirm idempotent handling. Grep for `cancelTimer|clearCustomerActiveBroadcast` to confirm Redis cleanup.
  </verify>
  <done>
`cancelOrder()` uses atomic `updateMany` with status precondition. Already-cancelled returns `{ success: true }` (idempotent). Full Redis cleanup: order timer, customer active key, idempotency key. TruckRequests in searching/held state cancelled atomically. Cancel-vs-accept race handled by reverting pending assignments. Transporters notified via existing fan-out pattern.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Both cancelBooking and cancelOrder use atomic `updateMany` with status precondition
3. Both return success (not error) on already-cancelled
4. Both clear all Redis state: timers, notified set, customer active key, idempotency key
5. Both handle cancel-vs-accept race by reverting recent assignments
6. Both notify customer and transporters via WebSocket
7. Existing notification logic preserved
</verification>

<success_criteria>
- Cancel is atomic: single UPDATE WHERE status IN (active, partially_filled)
- Cancel is idempotent: already-cancelled returns success
- Cancel clears ALL Redis state (5 key types)
- Cancel-vs-accept race: cancel wins, assignments reverted
- Existing return types and notification patterns preserved
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-broadcast-lifecycle-correctness/01-05-SUMMARY.md`
</output>
