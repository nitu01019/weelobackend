---
phase: 01-broadcast-lifecycle-correctness
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/modules/booking/order.service.ts
  - src/modules/order/order.service.ts
autonomous: true
requirements:
  - ACPT-01
  - ACPT-02
  - ACPT-03
  - ACPT-04

must_haves:
  truths:
    - "Only one transporter can accept a given TruckRequest — concurrent accepts on the same request result in exactly one winner"
    - "The second concurrent acceptor receives a clear 'No longer available' / 'Request already taken' message"
    - "Both the booking/order.service.ts and order/order.service.ts acceptTruckRequest functions use atomic database operations"
    - "No read-check-write race condition exists in either accept path"
  artifacts:
    - path: "src/modules/booking/order.service.ts"
      provides: "Atomic acceptTruckRequest with Serializable transaction and updateMany optimistic lock"
      contains: "isolationLevel"
    - path: "src/modules/order/order.service.ts"
      provides: "Atomic acceptTruckRequest with Serializable transaction and updateMany optimistic lock"
      contains: "isolationLevel"
  key_links:
    - from: "src/modules/booking/order.service.ts"
      to: "prismaClient.$transaction"
      via: "Serializable isolation transaction wrapping the entire accept flow"
      pattern: "\\$transaction.*Serializable"
    - from: "src/modules/order/order.service.ts"
      to: "prismaClient.$transaction"
      via: "Serializable isolation transaction wrapping the entire accept flow"
      pattern: "\\$transaction.*Serializable"
    - from: "src/modules/booking/order.service.ts"
      to: "tx.truckRequest.updateMany"
      via: "Optimistic lock: WHERE id = requestId AND status = searching"
      pattern: "updateMany.*status.*searching"
    - from: "src/modules/order/order.service.ts"
      to: "tx.truckRequest.updateMany"
      via: "Optimistic lock: WHERE id = requestId AND status = searching"
      pattern: "updateMany.*status.*searching"
---

<objective>
Fix the double-assignment race condition in both Order path acceptTruckRequest functions by applying the proven atomic acceptance pattern from broadcast.service.ts (Serializable transaction + updateMany optimistic lock + P2034 retry loop).

Purpose: This is the HIGHEST-SEVERITY bug in the codebase. Two transporters accepting the same TruckRequest simultaneously can both succeed because the current code does a non-atomic read-check-write. This produces double-assignment data corruption — two drivers show up for one truck slot. The Booking path's acceptBroadcast in broadcast.service.ts already has the correct pattern. This plan applies that same pattern to both Order path accept functions.

Output: Both `booking/order.service.ts:acceptTruckRequest` and `order/order.service.ts:acceptTruckRequest` use atomic Serializable transactions with updateMany optimistic locks and P2034 retry loops.
</objective>

<execution_context>
@/Users/nitishbhardwaj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nitishbhardwaj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-RESEARCH.md
@src/modules/broadcast/broadcast.service.ts
@src/modules/booking/order.service.ts
@src/modules/order/order.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix atomic accept in booking/order.service.ts</name>
  <files>src/modules/booking/order.service.ts</files>
  <action>
Read `src/modules/booking/order.service.ts` and find the `acceptTruckRequest` method (around line 680). The current implementation does a non-atomic read-check-write:
1. Reads the TruckRequest to check `status === 'searching'`
2. Validates vehicle/transporter eligibility
3. Calls `db.updateTruckRequest(requestId, { status: 'assigned', ... })` without any atomicity guarantee

Also read `src/modules/broadcast/broadcast.service.ts` (around lines 404-605) as the REFERENCE IMPLEMENTATION for the correct pattern.

Replace the entire acceptTruckRequest method body with the atomic pattern:

```typescript
async acceptTruckRequest(
  requestId: string,
  transporterId: string,
  vehicleId: string,
  driverId?: string
): Promise<TruckRequestRecord> {
  const MAX_RETRIES = 3;

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const result = await prismaClient.$transaction(async (tx) => {
        // 1. Read inside transaction (Serializable guarantees consistent snapshot)
        const request = await tx.truckRequest.findUnique({ where: { id: requestId } });
        if (!request) {
          throw new AppError(404, 'TRUCK_REQUEST_NOT_FOUND', 'Truck request not found');
        }
        if (request.status !== 'searching') {
          throw new AppError(409, 'REQUEST_ALREADY_TAKEN', 'This request is no longer available');
        }

        // 2. Validate vehicle/transporter eligibility (all reads inside tx)
        // KEEP the existing validation logic from the current method —
        // vehicle ownership check, vehicle availability, driver check, etc.
        // Move all validation reads to use `tx.` prefix instead of `prismaClient.` or `db.`

        // 3. ATOMIC status transition via updateMany optimistic lock
        const updated = await tx.truckRequest.updateMany({
          where: {
            id: requestId,
            status: 'searching'  // Only succeeds if still 'searching'
          },
          data: {
            status: 'assigned',
            assignedTransporterId: transporterId,
            assignedVehicleId: vehicleId,
            assignedDriverId: driverId || null,
            assignedAt: new Date().toISOString()
          }
        });

        if (updated.count === 0) {
          // Another transporter won the race between our read and write
          throw new AppError(409, 'REQUEST_ALREADY_TAKEN', 'Request was just taken by another transporter');
        }

        // 4. Continue with the rest of the existing logic INSIDE the transaction:
        //    - Create assignment record (use tx.assignment.create)
        //    - Update order progress (trucksFilled increment via tx.order.updateMany with optimistic lock)
        //    - Generate tripId
        //    Keep all existing post-accept logic but use `tx.` for DB operations

        // 5. Fetch the updated request for return
        const updatedRequest = await tx.truckRequest.findUnique({ where: { id: requestId } });
        return updatedRequest!;
      }, { isolationLevel: 'Serializable' as any });

      // Post-transaction side effects (WebSocket, FCM — OUTSIDE transaction):
      // Keep existing notification logic here (emitToUser, FCM push, etc.)

      return result;
    } catch (error: any) {
      // Retry on serialization failure (P2034 from Prisma, 40001 from PostgreSQL)
      if ((error.code === 'P2034' || error.code === '40001') && attempt < MAX_RETRIES) {
        logger.warn(`Serialization failure on acceptTruckRequest attempt ${attempt}, retrying...`, { requestId });
        continue;
      }
      throw error;  // Re-throw AppError (409, 404) or unexpected errors
    }
  }

  throw new AppError(503, 'ACCEPT_RETRY_EXHAUSTED', 'Unable to process acceptance after retries. Please try again.');
}
```

CRITICAL RULES:
- Preserve ALL existing validation logic (vehicle type matching, transporter ownership, driver eligibility). Just move reads to use `tx.` prefix.
- Preserve ALL existing post-accept side effects (WebSocket events, FCM push, order status updates). Keep notification logic OUTSIDE the transaction to avoid holding the Serializable lock during I/O.
- The `updateMany` WHERE clause MUST include `status: 'searching'` as the optimistic lock. This is what prevents double-assignment.
- If the order's `trucksFilled` count needs to be incremented, use `tx.order.updateMany` with the current `trucksFilled` value as a WHERE condition (same optimistic lock pattern) to prevent double-increment.
- Do NOT change the method signature or return type.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compilation. Grep for `isolationLevel.*Serializable` in `src/modules/booking/order.service.ts` to confirm the transaction is present. Grep for `updateMany.*status.*searching` to confirm the optimistic lock. Grep for `P2034` to confirm the retry loop.
  </verify>
  <done>
`booking/order.service.ts:acceptTruckRequest` uses a Serializable transaction with updateMany optimistic lock (WHERE status = 'searching'). P2034 retry loop with 3 attempts. Concurrent accepts result in exactly one winner; losers get 409 'REQUEST_ALREADY_TAKEN'. All existing validation and notification logic preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix atomic accept in order/order.service.ts</name>
  <files>src/modules/order/order.service.ts</files>
  <action>
Read `src/modules/order/order.service.ts` and find the `acceptTruckRequest` method (around line 1325). This is the SECOND copy of the same bug. The current implementation does the same non-atomic read-check-write as `booking/order.service.ts`.

Apply the EXACT SAME atomic pattern as Task 1:

1. Wrap the entire method body in a retry loop (MAX_RETRIES = 3).
2. Inside the loop, wrap the accept flow in `prismaClient.$transaction(async (tx) => { ... }, { isolationLevel: 'Serializable' as any })`.
3. Move all reads inside the transaction (use `tx.` prefix).
4. Replace the status update with `tx.truckRequest.updateMany({ where: { id: truckRequestId, status: 'searching' }, data: { status: 'assigned', ... } })`.
5. Check `updated.count === 0` to detect the race — throw 409 'REQUEST_ALREADY_TAKEN'.
6. If `trucksFilled` needs incrementing on the parent Order, use `tx.order.updateMany` with optimistic lock on current `trucksFilled` value.
7. Catch `P2034` / `40001` errors and retry.
8. Keep all WebSocket/FCM notification logic OUTSIDE the transaction.

CRITICAL: This method has a different signature than the one in booking/order.service.ts (it returns `{ success, assignmentId, tripId, message }` instead of `TruckRequestRecord`). Preserve the existing return type. Adapt the pattern to match this method's structure.

CRITICAL: Read the existing method carefully — it may have additional logic like trip creation, assignment creation, or order progress tracking. All of these DB operations must happen INSIDE the transaction using `tx.` prefix. Only WebSocket/FCM/Redis side effects go outside.

Reference: `src/modules/broadcast/broadcast.service.ts:404-605` for the proven pattern.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compilation. Grep for `isolationLevel.*Serializable` in `src/modules/order/order.service.ts` to confirm the transaction is present. Grep for `updateMany.*status.*searching` to confirm the optimistic lock. Grep for `P2034` to confirm the retry loop. Verify both accept functions now have the same atomic pattern.
  </verify>
  <done>
`order/order.service.ts:acceptTruckRequest` uses a Serializable transaction with updateMany optimistic lock (WHERE status = 'searching'). P2034 retry loop with 3 attempts. Concurrent accepts result in exactly one winner; losers get 409 'REQUEST_ALREADY_TAKEN'. Existing return type and notification logic preserved. Both Order path accept functions are now atomic.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Both `booking/order.service.ts` and `order/order.service.ts` contain `$transaction` with `Serializable` isolation
3. Both contain `updateMany` with `status: 'searching'` as WHERE condition
4. Both contain P2034 retry logic with MAX_RETRIES = 3
5. Neither contains the old read-check-write pattern (no `if (request.status !== 'searching') { ... } db.updateTruckRequest(...)` outside a transaction)
6. No new TypeScript errors introduced
</verification>

<success_criteria>
- Zero read-check-write race conditions in either acceptTruckRequest function
- Both functions use Serializable transactions with updateMany optimistic lock
- Concurrent accept by two transporters: exactly one wins, other gets 409
- P2034 serialization failures are retried up to 3 times
- All existing validation, notification, and assignment logic preserved
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-broadcast-lifecycle-correctness/01-02-SUMMARY.md`
</output>
