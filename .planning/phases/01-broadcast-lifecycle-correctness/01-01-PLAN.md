---
phase: 01-broadcast-lifecycle-correctness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/core/constants/index.ts
  - src/modules/booking/booking.service.ts
  - src/modules/order/order.service.ts
  - src/shared/services/socket.service.ts
autonomous: true
requirements:
  - BCAST-01
  - BCAST-02
  - BCAST-03
  - BCAST-04
  - BCAST-05

must_haves:
  truths:
    - "Booking and Order records have explicit lifecycle states: created, broadcasting, active, partially_filled, fully_filled, completed, cancelled, expired"
    - "Every state transition is persisted in the database with a stateChangedAt timestamp"
    - "Terminal broadcasts (cancelled, expired, completed) emit WebSocket events to both customer and notified transporters"
    - "Transporters receive BOOKING_EXPIRED/BOOKING_CANCELLED events when broadcast reaches terminal state"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Extended BookingStatus and OrderStatus enums with created and broadcasting values, plus stateChangedAt field"
      contains: "created"
    - path: "src/core/constants/index.ts"
      provides: "Updated BookingStatus and OrderStatus TypeScript enums matching Prisma schema"
      contains: "broadcasting"
  key_links:
    - from: "src/modules/booking/booking.service.ts"
      to: "prisma/schema.prisma"
      via: "Prisma client uses extended enum values for status transitions"
      pattern: "status.*created|status.*broadcasting"
    - from: "src/modules/booking/booking.service.ts"
      to: "src/shared/services/socket.service.ts"
      via: "emitToUser on every state transition"
      pattern: "emitToUser.*BROADCAST_STATE_CHANGED|emitToUser.*BOOKING_EXPIRED"
---

<objective>
Add explicit broadcast lifecycle states (Created, Broadcasting, Active, Terminal variants) to the database schema and service layer, with DB-persisted transitions, timestamps, and real-time WebSocket notifications.

Purpose: The broadcast state machine currently has implicit transitions â€” bookings jump straight to "active" with no created/broadcasting intermediate states, and state changes lack timestamps. This makes debugging impossible and prevents the frontend from showing accurate broadcast progress. Explicit states with timestamps provide the audit trail needed for correctness verification and real-time UI updates.

Output: Extended Prisma enums, stateChangedAt field, migration, updated service layer to use new states with WebSocket emission on every transition.
</objective>

<execution_context>
@/Users/nitishbhardwaj/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nitishbhardwaj/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-broadcast-lifecycle-correctness/01-RESEARCH.md
@prisma/schema.prisma
@src/core/constants/index.ts
@src/modules/booking/booking.service.ts
@src/modules/order/order.service.ts
@src/shared/services/socket.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema with lifecycle states and stateChangedAt</name>
  <files>prisma/schema.prisma, src/core/constants/index.ts</files>
  <action>
1. In `prisma/schema.prisma`, add two new values to the `BookingStatus` enum: `created` (before `active`) and `broadcasting` (between `created` and `active`). The enum should read: created, broadcasting, active, partially_filled, fully_filled, in_progress, completed, cancelled, expired.

2. Do the same for the `OrderStatus` enum: add `created` and `broadcasting` in the same positions.

3. Add a `stateChangedAt` DateTime field (optional, `DateTime?`) to both the `Booking` model and the `Order` model. This tracks the timestamp of the last state transition. Set `@default(now())` so existing records get a value.

4. In `src/core/constants/index.ts`, find the TypeScript `BookingStatus` and `OrderStatus` enums (or constants object) and add the `created` and `broadcasting` values to match the Prisma schema. Keep the existing values unchanged.

5. Run `npx prisma generate` to regenerate the Prisma client types.

6. Create a Prisma migration: `npx prisma migrate dev --name add-broadcast-lifecycle-states`. This is an additive enum change (new values) plus a new nullable column, so it is backward-compatible with existing data. Existing rows with `active` status remain valid.

IMPORTANT: Do NOT change any existing enum values or rename them. This is purely additive. The `active` status continues to mean "awaiting responses from transporters" as it does today.
  </action>
  <verify>
Run `npx prisma generate` and `npx prisma validate` -- both must succeed with zero errors. Verify the generated Prisma client includes `created` and `broadcasting` as valid values for BookingStatus and OrderStatus. Run `npx tsc --noEmit` to confirm TypeScript compilation passes with the updated constants.
  </verify>
  <done>
BookingStatus enum has: created, broadcasting, active, partially_filled, fully_filled, in_progress, completed, cancelled, expired. OrderStatus enum has the same set. Both Booking and Order models have a `stateChangedAt` DateTime field. Prisma client is regenerated. TypeScript constants match. Migration file exists in prisma/migrations/.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire lifecycle state transitions with timestamps and WebSocket events in service layer</name>
  <files>src/modules/booking/booking.service.ts, src/modules/order/order.service.ts, src/shared/services/socket.service.ts</files>
  <action>
1. In `src/modules/booking/booking.service.ts`, find `createBooking()`. Currently it creates the booking with `status: 'active'`. Change this to create with `status: 'created'` and `stateChangedAt: new Date()`. Then, AFTER transporters are found and notifications are sent, update the status to `broadcasting` with a new `stateChangedAt`. Then, after the broadcast timer is set and the function is ready to return, update to `active`. Each transition should:
   - Update the DB: `await prismaClient.booking.update({ where: { id }, data: { status: newStatus, stateChangedAt: new Date() } })`
   - Emit a WebSocket event to the customer: `emitToUser(customerId, 'BROADCAST_STATE_CHANGED', { bookingId, status: newStatus, stateChangedAt })`

2. In `src/modules/order/order.service.ts`, find `createOrder()`. Apply the same pattern: start as `created`, transition to `broadcasting` after transporters are notified, then to `active`. Emit `BROADCAST_STATE_CHANGED` to customer on each transition.

3. For terminal state transitions that ALREADY EXIST (cancelled, expired, fully_filled, completed), add `stateChangedAt: new Date()` to each existing update call. Also ensure a WebSocket event is emitted to the customer AND to all notified transporters. For transporters on terminal states, use the existing patterns:
   - `BOOKING_EXPIRED` event (already exists for expiry)
   - `BOOKING_CANCELLED` event for cancel
   - `BOOKING_FULLY_FILLED` event (already exists)
   Ensure each terminal event includes `{ bookingId/orderId, status, stateChangedAt }`.

4. In `src/shared/services/socket.service.ts`, add `BROADCAST_STATE_CHANGED` to the SocketEvent enum/object if it uses one. If socket events are string literals, just use the string `'BROADCAST_STATE_CHANGED'` in the service calls.

5. For BCAST-05 (terminal broadcasts removed from transporter views): verify that existing terminal events (BOOKING_EXPIRED, BOOKING_CANCELLED, BOOKING_FULLY_FILLED) are emitted to ALL notified transporters for a broadcast, not just the customer. The existing pattern for BOOKING_EXPIRED in `handleBookingTimeout` already fans out to notified transporters. Make sure BOOKING_CANCELLED does the same (this will be fully fixed in Plan 05 for cancel, but add the emit here for the existing cancel path).

IMPORTANT: Do NOT modify the `acceptTruckRequest` functions (those are Plan 02's scope). Do NOT modify the one-per-customer guard logic (Plan 03). Only add lifecycle state tracking and WebSocket emissions to existing create and terminal paths.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compilation passes. Search the modified files for `stateChangedAt` to confirm it appears in all state transition update calls. Search for `BROADCAST_STATE_CHANGED` to confirm WebSocket events are emitted on create -> broadcasting -> active transitions. Verify `BOOKING_CANCELLED` and `BOOKING_EXPIRED` events include `stateChangedAt` in their payload.
  </verify>
  <done>
Every booking/order state transition (created -> broadcasting -> active -> terminal) persists `stateChangedAt` timestamp in the database. Every transition emits a `BROADCAST_STATE_CHANGED` WebSocket event to the customer. Terminal state transitions emit appropriate events (BOOKING_EXPIRED, BOOKING_CANCELLED, BOOKING_FULLY_FILLED) to all notified transporters, enabling client-side removal from actionable views.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes
2. `npx tsc --noEmit` passes
3. Prisma migration file exists in `prisma/migrations/` directory
4. Grep for `stateChangedAt` in booking.service.ts and order/order.service.ts shows it in every status update call
5. Grep for `BROADCAST_STATE_CHANGED` shows WebSocket events on state transitions
6. Grep for `BOOKING_CANCELLED` shows it being emitted to notified transporters (not just customer)
</verification>

<success_criteria>
- BookingStatus and OrderStatus enums include created, broadcasting as new values
- Both Booking and Order models have stateChangedAt DateTime field
- createBooking() transitions: created -> broadcasting -> active with DB persistence and WebSocket events
- createOrder() transitions: created -> broadcasting -> active with DB persistence and WebSocket events
- All terminal transitions include stateChangedAt in their update call
- Terminal events (expired, cancelled, fully_filled) fan out to all notified transporters
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-broadcast-lifecycle-correctness/01-01-SUMMARY.md`
</output>
